# -*- coding: utf-8 -*-
"""lab4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bh6XImx_E863m2C2C1gw2wPUMHMpkGVw
"""

import math
import matplotlib.pyplot as plt

# Ввод с клавиатуры
def read_data_console():
    n = int(input("Введите количество точек: "))
    x, y = [], []
    for _ in range(n):
        xi, yi = map(float, input("Введите x и y: ").split())
        x.append(xi)
        y.append(yi)
    return x, y

# Ввод из файла: формат — по одной паре x y на строку
def read_data_file():
    filename = input("Введите имя файла: ")
    x, y = [], []
    with open(filename, 'r') as f:
        for line in f:
            if line.strip():
                xi, yi = map(float, line.strip().split())
                x.append(xi)
                y.append(yi)
    return x, y



def mean(values):
    return sum(values) / len(values)


# Решение системы линейных уравнений методом Гаусса
def solve_slae(A, b):
    n = len(b)

    for i in range(n):
        max_row = max(range(i, n), key=lambda k: abs(A[k][i]))
        A[i], A[max_row] = A[max_row], A[i]
        b[i], b[max_row] = b[max_row], b[i]

        for j in range(i + 1, n):
            coef = A[j][i] / A[i][i]
            for k in range(i, n):
                A[j][k] -= coef * A[i][k]
            b[j] -= coef * b[i]

    x = [0] * n
    for i in reversed(range(n)):
        s = sum(A[i][j] * x[j] for j in range(i + 1, n))
        x[i] = (b[i] - s) / A[i][i]
    return x



# Линейная: y = a·x + b
def lin_approx(x, y):

    #Строим приближающую прямую y = a·x + b по МНК.
    n = len(x)
    sx = sum(x)
    sy = sum(y)
    sxx = sum(xi**2 for xi in x)
    sxy = sum(xi * yi for xi, yi in zip(x, y))

    # Решаем систему:
    # a * Σx^2 + b * Σx = Σx*y
    # a * Σx   + b * n  = Σy

    a = (n * sxy - sx * sy) / (n * sxx - sx**2)
    b = (sy - a * sx) / n

    return lambda t: a * t + b, (a, b)

# Квадратичная: y = a2·x² + a1·x + a0
def quad_approx(x, y):

    #Строим параболу по методу наименьших квадратов.
    n = len(x)

    # Вычисляем все необходимые суммы:
    sx = sum(x)
    sx2 = sum(xi**2 for xi in x)
    sx3 = sum(xi**3 for xi in x)
    sx4 = sum(xi**4 for xi in x)
    sy = sum(y)
    sxy = sum(xi * yi for xi, yi in zip(x, y))
    sx2y = sum(xi**2 * yi for xi, yi in zip(x, y))

    # Составляем систему:
    # a2*Σx^4 + a1*Σx^3 + a0*Σx^2 = Σx^2·y
    # a2*Σx^3 + a1*Σx^2 + a0*Σx   = Σx·y
    # a2*Σx^2 + a1*Σx   + a0*n    = Σy

    A = [
        [sx4, sx3, sx2],
        [sx3, sx2, sx],
        [sx2, sx,  n]
    ]
    b = [sx2y, sxy, sy]

    a2, a1, a0 = solve_slae(A, b)

    return lambda t: a2 * t**2 + a1 * t + a0, (a2, a1, a0)


# Кубическая: y = a3·x³ + a2·x² + a1·x + a0
def cubic_approx(x, y):

    # Строим кубическую кривую по методу наименьших квадратов.
    n = len(x)

    # Вычисляем все суммы до шестой степени
    sx = sum(x)
    sx2 = sum(xi**2 for xi in x)
    sx3 = sum(xi**3 for xi in x)
    sx4 = sum(xi**4 for xi in x)
    sx5 = sum(xi**5 for xi in x)
    sx6 = sum(xi**6 for xi in x)
    sy = sum(y)
    sxy = sum(xi * yi for xi, yi in zip(x, y))
    sx2y = sum(xi**2 * yi for xi, yi in zip(x, y))
    sx3y = sum(xi**3 * yi for xi, yi in zip(x, y))

    # Составляем систему на 4 неизвестных: a3, a2, a1, a0
    A = [
        [sx6, sx5, sx4, sx3],
        [sx5, sx4, sx3, sx2],
        [sx4, sx3, sx2, sx],
        [sx3, sx2, sx,  n]
    ]
    b = [sx3y, sx2y, sxy, sy]

    a3, a2, a1, a0 = solve_slae(A, b)

    return lambda t: a3*t**3 + a2*t**2 + a1*t + a0, (a3, a2, a1, a0)


# Экспоненциальная: y = a·e^(b·x)
def exp_approx(x, y):
    # Линеаризуем модель: ln(y) = ln(a) + b·x, решаем как линейную.

    Y = [math.log(yi) for yi in y]  # ln(y)
    f, (b, ln_a) = lin_approx(x, Y)
    a = math.exp(ln_a)
    return lambda t: a * math.exp(b * t), (a, b)


# Логарифмическая: y = a·ln(x) + b
def log_approx(x, y):

    #Аппроксимация функции вида y = a * ln(x) + b
    #Работает только для x > 0
    # Проверка на допустимость значений

    if any(xi <= 0 for xi in x):
        raise ValueError("Логарифмическая аппроксимация применима только при x > 0")

    # Логарифмируем x
    X = [math.log(xi) for xi in x]

    # Аппроксимируем линейной функцией: ln(x) → X, y — без изменений
    f_lin, (a, b) = lin_approx(X, y)

    # Возвращаем восстановленную функцию по x: y = a * ln(x) + b
    def f_log(t):
        if t <= 0:
            return float('nan')  # безопасное значение при попытке log(0) или log(<0)
        return a * math.log(t) + b

    return f_log, (a, b)

# Степенная: y = a·x^b
def power_approx(x, y):
    # Логарифмируем обе переменные: ln(y) = ln(a) + b·ln(x)

    X = [math.log(xi) for xi in x]
    Y = [math.log(yi) for yi in y]
    f, (b, ln_a) = lin_approx(X, Y)
    a = math.exp(ln_a)
    return lambda t: a * t**b, (a, b)


# Среднеквадратическое отклонение
def deviation(f, x, y):
    return math.sqrt(sum((f(xi) - yi)**2 for xi, yi in zip(x, y)) / len(x))


# Коэффициент корреляции Пирсона
def correlation(x, y):
    mx, my = mean(x), mean(y)
    num = sum((xi - mx) * (yi - my) for xi, yi in zip(x, y))
    den = math.sqrt(sum((xi - mx)**2 for xi in x) * sum((yi - my)**2 for yi in y))
    return num / den

# Коэффициент детерминации
def determination(r):
    R2 = r**2
    if R2 > 0.9:
        msg = "сильная зависимость"
    elif R2 > 0.7:
        msg = "умеренная зависимость"
    else:
        msg = "слабая зависимость"
    return R2, msg



def main():
    print("Выберите способ ввода данных:")
    print("1 - Ввод с клавиатуры")
    print("2 - Ввод из файла")
    choice = input("Ваш выбор: ")

    if choice == "1":
        x, y = read_data_console()
    elif choice == "2":
        x, y = read_data_file()
    else:
        print("Неверный выбор.")
        return

    funcs = {
        "Линейная": lin_approx,
        "Квадратичная": quad_approx,
        "Кубическая": cubic_approx,
        "Экспоненциальная": exp_approx,
        "Логарифмическая": log_approx,
        "Степенная": power_approx
    }

    results = {}
    for name, approx in funcs.items():
        try:
            f, coeffs = approx(x, y)
            dev = deviation(f, x, y)
            results[name] = (f, coeffs, dev)
            print(f"{name}: коэффициенты = {coeffs}, отклонение = {dev:.3f}")
        except Exception as e:
            print(f"{name}: ошибка ({e})")

    best = min(results.items(), key=lambda item: item[1][2])
    print(f"\n Лучшая аппроксимация: {best[0]}")

    if "Линейная" in results:
        r = correlation(x, y)
        R2, msg = determination(r)
        print(f"Коэф. корреляции: {r:.3f}, детерминации: {R2:.3f} — {msg}")

    # Построение графиков
    plt.scatter(x, y, label="Исходные данные", color="black")
    min_x, max_x = min(x), max(x)
    t_vals = [min_x - 1 + i * 0.1 for i in range(int((max_x - min_x + 2) * 10))]
    for name, (f, _, _) in results.items():
        y_vals = [f(t) for t in t_vals]
        plt.plot(t_vals, y_vals, label=name)

    plt.legend()
    plt.grid()
    plt.title("Аппроксимации методом наименьших квадратов")
    plt.show()

if __name__ == "__main__":
    main()