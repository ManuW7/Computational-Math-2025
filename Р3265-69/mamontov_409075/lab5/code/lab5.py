# -*- coding: utf-8 -*-
"""lab5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/103T3_L_UMKZL9wyCRlgRSQmFTqinB9rQ
"""

import math
import matplotlib.pyplot as plt

# Метод Лагранжа: позволяет интерполировать значение функции в точке x,
# используя формулу, в которой каждый член строится на основе всех других x.
def lagrange_interpolation(x_values, y_values, x):
    result = 0
    n = len(x_values)
    for i in range(n):
        term = y_values[i]  # начинаем с y_i
        for j in range(n):
            if i != j:
                # умножаем на (x - x_j) / (x_i - x_j) для всех j ≠ i
                # эта часть формирует базисный полином L_i(x)
                term *= (x - x_values[j]) / (x_values[i] - x_values[j])
        result += term  # суммируем все члены: f(x) ≈ Σ y_i * L_i(x)
    return result

# Метод Ньютона (разделённые разности): работает с любыми x, даже если шаг не одинаковый
# Постепенно строится таблица разделённых разностей, используется для построения полинома

def newton_divided_differences(x_values, y_values, x):
    n = len(x_values)
    coef = y_values.copy()  # коэффициенты разделённых разностей, начнем с y_i
    for j in range(1, n):
        for i in range(n - 1, j - 1, -1):
            # формула разделённой разности:
            # f[x_i,...,x_{i-j}] = (f[x_i,...,x_{i-j+1}] - f[x_{i-1},...,x_{i-j}]) / (x_i - x_{i-j})
            coef[i] = (coef[i] - coef[i - 1]) / (x_values[i] - x_values[i - j])
    result = coef[-1]  # начинаем с самого последнего коэффициента
    for i in range(n - 2, -1, -1):
        # полином строится справа налево: P(x) = (...(a_n * (x - x_{n-1}) + a_{n-1})...) + a_0
        result = result * (x - x_values[i]) + coef[i]
    return result

# Метод Ньютона (конечные разности вперёд): требует равномерный шаг между x
# Строим таблицу разностей, используем t = (x - x0) / h

def newton_forward_difference(x_values, y_values, x):
    n = len(x_values)
    h = x_values[1] - x_values[0]  # вычисляем шаг h
    for i in range(1, n - 1):
        if abs((x_values[i + 1] - x_values[i]) - h) > 1e-10:
            raise ValueError("x не равномерны — метод Ньютона с конечными разностями неприменим.")
    diff_table = [y_values.copy()]  # первая строка таблицы — значения функции
    for i in range(1, n):
        current_diff = []
        for j in range(n - i):
            # вычисляем разности: Δ^k f(x) = Δ^{k-1} f(x_{i+1}) - Δ^{k-1} f(x_i)
            current_diff.append(diff_table[i - 1][j + 1] - diff_table[i - 1][j])
        diff_table.append(current_diff)
    t = (x - x_values[0]) / h  # нормализованное расстояние до x0
    result = y_values[0]  # начинаем с f(x0)
    term = 1
    for i in range(1, n):
        # вычисляем t(t - 1)(t - 2)... / i!
        term *= (t - (i - 1)) / i
        # добавляем i-ю разность, умноженную на соответствующий коэффициент
        result += term * diff_table[i][0]
    return result

# Метод Ньютона (конечные разности назад): аналогично вперёд, но от последнего узла

def newton_backward_difference(x_values, y_values, x):
    n = len(x_values)
    h = x_values[1] - x_values[0]  # шаг
    for i in range(1, n - 1):
        if abs((x_values[i + 1] - x_values[i]) - h) > 1e-10:
            raise ValueError("x не равномерны — метод назад неприменим.")
    diff_table = [y_values.copy()]  # начальные значения
    for i in range(1, n):
        current_diff = []
        for j in range(n - i):
            # строим таблицу разностей, как и для метода вперёд
            current_diff.append(diff_table[i - 1][j + 1] - diff_table[i - 1][j])
        diff_table.append(current_diff)
    t = (x - x_values[-1]) / h  # нормализованное расстояние от последнего узла
    result = y_values[-1]  # начинаем с f(x_n)
    term = 1
    for i in range(1, n):
        # коэффициенты вида t(t+1)(t+2)... / i!
        term *= (t + i - 1) / i
        # добавляем соответствующую разность с конца таблицы
        result += term * diff_table[i][-1]
    return result

#Ввод данных
def input_points_from_keyboard():
    print("Введите количество точек:")
    n = int(input())
    x_values = []
    y_values = []
    print("Введите значения x и y через пробел, по одной паре на строку:")
    for _ in range(n):
        x, y = map(float, input().split())
        x_values.append(x)
        y_values.append(y)
    return x_values, y_values

def input_points_from_file():
    print("Введите путь к файлу: ")
    filename = input().strip()
    x_values, y_values = [], []
    with open(filename, 'r') as f:
        for line in f:
            x, y = map(float, line.strip().split())
            x_values.append(x)
            y_values.append(y)
    return x_values, y_values

def input_points_from_function():
    print("Выберите функцию:")
    print("1 — sin(x)")
    print("2 — cos(x)")
    print("3 — exp(x)")
    choice = input("Ваш выбор: ")
    func = math.sin
    if choice == '2':
        func = math.cos
    elif choice == '3':
        func = math.exp

    a = float(input("Начало интервала: "))
    b = float(input("Конец интервала: "))
    n = int(input("Количество точек: "))
    x_values = [a + i * (b - a) / (n - 1) for i in range(n)]
    y_values = [func(x) for x in x_values]
    return x_values, y_values

#Таблица конечных разностей
def print_forward_difference_table(x_values, y_values):
    n = len(x_values)
    table = [y_values.copy()]
    for i in range(1, n):
        row = [table[i - 1][j + 1] - table[i - 1][j] for j in range(n - i)]
        table.append(row)
    print("\nТаблица конечных разностей:")
    for i in range(n):
        print(f"{x_values[i]:>6.3f} |", end='')
        for j in range(n - i):
            print(f" {table[j][i]:>10.6f}", end='')
        print()

#Графики
def plot_interpolation(x_values, y_values, method_func, label):
    xs = [x_values[0] + i * 0.01 for i in range(int((x_values[-1] - x_values[0]) / 0.01) + 1)]
    ys = [method_func(x_values, y_values, x) for x in xs]
    plt.plot(xs, ys, label=label)


def main():
    print("Выберите способ ввода данных:")
    print("1 — ввод с клавиатуры")
    print("2 — ввод из файла")
    print("3 — по заданной функции")
    choice = input("Ваш выбор: ")

    if choice == '1':
        x_values, y_values = input_points_from_keyboard()
    elif choice == '2':
        x_values, y_values = input_points_from_file()
    elif choice == '3':
        x_values, y_values = input_points_from_function()
    else:
        print("Неверный выбор.")
        return

    print_forward_difference_table(x_values, y_values)

    x = float(input("Введите значение x, в котором нужно интерполировать: "))

    try:
        l = lagrange_interpolation(x_values, y_values, x)
        print(f"Значение по Лагранжу: {l:.6f}")
    except Exception as e:
        print(f"Ошибка Лагранжа: {e}")

    try:
        nd = newton_divided_differences(x_values, y_values, x)
        print(f"Ньютон (разделённые): {nd:.6f}")
    except Exception as e:
        print(f"Ошибка Ньютона (разделённые): {e}")

    try:
        nf = newton_forward_difference(x_values, y_values, x)
        print(f"Ньютон (вперёд): {nf:.6f}")
    except Exception as e:
        print(f"Ошибка Ньютона (вперёд): {e}")

    try:
        nb = newton_backward_difference(x_values, y_values, x)
        print(f"Ньютон (назад): {nb:.6f}")
    except Exception as e:
        print(f"Ошибка Ньютона (назад): {e}")

    # Построение графиков
    plt.figure(figsize=(10, 6))
    plt.scatter(x_values, y_values, color='black', label='Узлы')
    try:
        plot_interpolation(x_values, y_values, lagrange_interpolation, 'Лагранж')
    except:
        pass
    try:
        plot_interpolation(x_values, y_values, newton_divided_differences, 'Ньютон (разделённые)')
    except:
        pass
    try:
        plot_interpolation(x_values, y_values, newton_forward_difference, 'Ньютон (вперёд)')
    except:
        pass
    try:
        plot_interpolation(x_values, y_values, newton_backward_difference, 'Ньютон (назад)')
    except:
        pass

    plt.title("Интерполяционные многочлены")
    plt.xlabel("x")
    plt.ylabel("f(x)")
    plt.grid(True)
    plt.legend()
    plt.show()

if __name__ == '__main__':
    main()