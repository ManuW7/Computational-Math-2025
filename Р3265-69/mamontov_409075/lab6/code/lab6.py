# -*- coding: utf-8 -*-
"""lab6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mUMvb78cVWu84ETx80h_ktkez1grPSXw
"""

import numpy as np
import matplotlib.pyplot as plt
import math

# 1. y' = y - x^2 + 1, точное решение: y = (x + 1)^2 - 0.5e^x
def f1(x, y):
    return y - x**2 + 1

def f1_exact(x):
    return (x + 1)**2 - 0.5 * math.exp(x)

# 2. y' = x * sqrt(y), точное решение: y = (x^2 / 4 + sqrt(y0))^2
def f2(x, y):
    return x * math.sqrt(y)

def f2_exact(x, y0):
    return (x**2 / 4 + math.sqrt(y0))**2

# 3. y' = x + y, точное решение: y = Ce^x - x - 1
def f3(x, y):
    return x + y

def f3_exact(x, x0, y0):
    C = (y0 + x0 + 1) * math.exp(-x0)
    return C * math.exp(x) - x - 1

def choose_equation(x0, y0):
    print("Выберите ОДУ для решения:")
    print("1: y' = y - x^2 + 1")
    print("2: y' = x * sqrt(y)")
    print("3: y' = x + y")

    while True:
        choice = input("Введите номер уравнения (1, 2 или 3): ")
        if choice == '1':
            return f1, f1_exact
        elif choice == '2':
            return f2, lambda x: f2_exact(x, y0)
        elif choice == '3':
            return f3, lambda x: f3_exact(x, x0, y0)
        else:
            print("Неверный выбор. Повторите.")


def get_user_input():
    x0 = float(input("Введите x0: "))
    y0 = float(input("Введите y0: "))
    xn = float(input("Введите xn: "))
    h = float(input("Введите шаг h: "))
    eps = float(input("Введите точность eps: "))
    return x0, y0, xn, h, eps

#Метод Эйлера
def euler_method(f, x0, y0, xn, h):
    x_vals = [x0]
    y_vals = [y0]
    x = x0
    y = y0
    # Шаг за шагом вычисляем y_{i+1} = y_i + h*f(x_i, y_i)
    while x < xn:
        y += h * f(x, y)
        x = round(x + h, 10)
        x_vals.append(x)
        y_vals.append(y)
    return x_vals, y_vals

#Метод Рунге-Кутта 4-го порядка
def runge_kutta_method(f, x0, y0, xn, h):
    x_vals = [x0]
    y_vals = [y0]
    x = x0
    y = y0
    # Вычисляем y_{i+1} с помощью взвешенного среднего значений производных
    while x < xn:
        k1 = h * f(x, y)
        k2 = h * f(x + h / 2, y + k1 / 2)
        k3 = h * f(x + h / 2, y + k2 / 2)
        k4 = h * f(x + h, y + k3)
        y += (k1 + 2*k2 + 2*k3 + k4) / 6
        x = round(x + h, 10)
        x_vals.append(x)
        y_vals.append(y)
    return x_vals, y_vals

#Метод Милна (предиктор-корректор)
def milne_method(f, x0, y0, xn, h):
    # Сначала получаем 4 стартовые точки методом Рунге-Кутта
    x_init, y_init = runge_kutta_method(f, x0, y0, x0 + 3 * h, h)
    x_vals = x_init.copy()
    y_vals = y_init.copy()
    i = 3
    # На каждом шаге:
    # Предиктор: y_{i+1} = y_{i-3} + (4h/3)(2f_{i-2} - f_{i-1} + 2f_i)
    # Корректор: y_{i+1} = y_{i-1} + (h/3)(f_{i-1} + 4f_i + f_{i+1})
    while x_vals[-1] < xn:
        y_pred = y_vals[i-3] + (4*h/3)*(2*f(x_vals[i-2], y_vals[i-2]) - f(x_vals[i-1], y_vals[i-1]) + 2*f(x_vals[i], y_vals[i]))
        x_next = round(x_vals[i] + h, 10)
        f_next = f(x_next, y_pred)
        y_corr = y_vals[i-1] + (h/3)*(f(x_vals[i-1], y_vals[i-1]) + 4*f(x_vals[i], y_vals[i]) + f_next)
        x_vals.append(x_next)
        y_vals.append(y_corr)
        i += 1
    return x_vals, y_vals

#Таблица решений
def print_table(x_vals, y_vals, y_exact_func):
    print(f"{'x':>10} | {'y (числ.)':>15} | {'y (точн.)':>15} | {'|погр|':>10}")
    print("-" * 60)
    for x, y_num in zip(x_vals, y_vals):
        y_exact = y_exact_func(x)
        error = abs(y_exact - y_num)
        print(f"{x:10.5f} | {y_num:15.8f} | {y_exact:15.8f} | {error:10.2e}")

#Правило Рунге для вычисления ошибок
def runge_error(method, f, x0, y0, xn, h, p):
    # Решения при шаге h и h/2
    _, y_h = method(f, x0, y0, xn, h)
    _, y_half = method(f, x0, y0, xn, h / 2)

    # Сравниваем только те точки, которые совпадают по x
    y_half_aligned = y_half[::2]  # каждая вторая точка из шага h/2

    errors = [abs(y_big - y_small) / (2**p - 1) for y_big, y_small in zip(y_h, y_half_aligned)]
    return max(errors)

#Построение графиков
def plot_solutions(x_vals, y1, y2, y3, y_exact_func):
    x_exact = np.linspace(x_vals[0], x_vals[-1], 200)
    y_exact = [y_exact_func(x) for x in x_exact]
    plt.figure(figsize=(10, 6))
    plt.plot(x_exact, y_exact, label='Точное решение', color='black', linewidth=2)
    plt.plot(x_vals, y1, 'o-', label='Метод Эйлера', color='blue')
    plt.plot(x_vals, y2, 's-', label='Метод Рунге-Кутта', color='green')
    plt.plot(x_vals, y3, '^-', label='Метод Милна', color='red')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('Численные и точные решения ОДУ')
    plt.legend()
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    x0, y0, xn, h, eps = get_user_input()
    f, exact = choose_equation(x0, y0)

    x_e, y_euler = euler_method(f, x0, y0, xn, h)
    x_rk, y_rk = runge_kutta_method(f, x0, y0, xn, h)
    x_milne, y_milne = milne_method(f, x0, y0, xn, h)

    print("\nРезультаты метода Эйлера:")
    print_table(x_e, y_euler, exact)

    print("\nРезультаты метода Рунге-Кутта:")
    print_table(x_rk, y_rk, exact)

    print("\nРезультаты метода Милна:")
    print_table(x_milne, y_milne, exact)

    min_len = min(len(x_e), len(y_rk), len(y_milne))

    x_vals_common = x_e[:min_len]
    y_euler_trimmed = y_euler[:min_len]
    y_rk_trimmed = y_rk[:min_len]
    y_milne_trimmed = y_milne[:min_len]

    plot_solutions(x_vals_common, y_euler_trimmed, y_rk_trimmed, y_milne_trimmed, exact)

    # Оценка точности по правилу Рунге
    euler_runge_error = runge_error(euler_method, f, x0, y0, xn, h, p=1)
    rk_runge_error = runge_error(runge_kutta_method, f, x0, y0, xn, h, p=4)

    # Оценка ошибки метода Милна через точное решение
    milne_errors = [abs(exact(x) - y) for x, y in zip(x_milne, y_milne)]
    milne_max_error = max(milne_errors)

    print(f"\nПогрешность метода Эйлера по правилу Рунге: {euler_runge_error:.2e}")
    print(f"Погрешность метода Рунге-Кутта по правилу Рунге: {rk_runge_error:.2e}")
    print(f"Максимальная погрешность метода Милна (сравнение с точным): {milne_max_error:.2e}")