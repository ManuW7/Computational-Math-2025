# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17OdidLbk-OukHDjd1h0XM-D2OYoiy5QT
"""

import matplotlib.pyplot as plt
import numpy as np
import math
from typing import Callable, Tuple, Optional

class NonlinearEquationSolver:
    def __init__(self):
        self.equations = {
            1: ("x^3 - x + 1", lambda x: x**3 - x + 1),
            2: ("sin(x) + 0.5", lambda x: math.sin(x) + 0.5),
            3: ("e^x - 2", lambda x: math.exp(x) - 2),
            4: ("x^2 - 4", lambda x: x**2 - 4),
            5: ("cos(x) - x", lambda x: math.cos(x) - x)
        }
        self.methods = {
            1: ("Метод хорд", self.chord_method),
            2: ("Метод секущих", self.secant_method),
            3: ("Метод простой итерации", self.simple_iteration_method)
        }

    def display_menu(self, items: dict, title: str) -> int:
        """Отображает меню и возвращает выбор пользователя"""
        print(f"\n{title}:")
        for key, (desc, _) in items.items():
            print(f"{key}. {desc}")
        while True:
            try:
                choice = int(input("Выберите пункт: "))
                if choice in items:
                    return choice
                print("Неверный выбор. Попробуйте снова.")
            except ValueError:
                print("Введите число.")

    def get_input_source(self) -> Tuple[float, float, float]:
        """Получает источник ввода данных"""
        print("\nВыберите источник ввода данных:")
        print("1. Клавиатура")
        print("2. Файл")
        choice = input("Ваш выбор: ")

        if choice == "1":
            a = float(input("Введите левую границу интервала a: "))
            b = float(input("Введите правую границу интервала b: "))
            eps = float(input("Введите точность eps: "))
            return a, b, eps
        elif choice == "2":
            filename = input("Введите имя файла: ")
            with open(filename, 'r') as f:
                a, b, eps = map(float, f.readline().split())
            return a, b, eps

    def get_output_destination(self) -> str:
        """Получает место вывода результатов"""
        print("\nВыберите куда выводить результаты:")
        print("1. Экран")
        print("2. Файл")
        choice = input("Ваш выбор: ")
        return "screen" if choice == "1" else "file"

    def verify_interval(self, f: Callable[[float], float], a: float, b: float) -> bool:
        """Проверяет наличие корня на интервале"""
        if a >= b:
            print("Ошибка: a должно быть меньше b")
            return False

        fa = f(a)
        fb = f(b)

        if fa * fb > 0:
            print(f"Ошибка: На интервале [{a}, {b}] функция не меняет знак (f(a)={fa:.3f}, f(b)={fb:.3f})")
            return False

        return True

    def find_initial_guess(self, f: Callable[[float], float], a: float, b: float) -> float:
        """Выбирает начальное приближение для методов"""
        fa = f(a)
        fb = f(b)
        return a if abs(fa) < abs(fb) else b

    def chord_method(self, f: Callable[[float], float], a: float, b: float, eps: float) -> Tuple[float, float, int]:
        """Метод хорд"""
        x_prev = a
        x_curr = b
        iterations = 0

        while True:
            iterations += 1
            x_next = x_curr - f(x_curr) * (x_curr - x_prev) / (f(x_curr) - f(x_prev))

            if abs(x_next - x_curr) < eps:
                break

            x_prev, x_curr = x_curr, x_next

        return x_next, f(x_next), iterations

    def secant_method(self, f: Callable[[float], float], a: float, b: float, eps: float) -> Tuple[float, float, int]:
        """Метод секущих"""
        x0 = a
        x1 = b
        iterations = 0

        while True:
            iterations += 1
            if abs(f(x1) - f(x0)) < 1e-12:
                print("Предупреждение: знаменатель близок к нулю в методе секущих")
                break

            x_next = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0))

            if abs(x_next - x1) < eps:
                break

            x0, x1 = x1, x_next

        return x_next, f(x_next), iterations

    def simple_iteration_method(self, f: Callable[[float], float], a: float, b: float, eps: float) -> Tuple[Optional[float], Optional[float], int]:
      """Метод простой итерации с строгой проверкой условия сходимости"""
      try:
          # Шаг для вычисления производных
          h = max((b - a) / 100, 1e-5)
          x_points = np.linspace(a, b, 100)

          # Вычисляем максимальное значение производной f
          df_values = []
          for x in x_points:
              try:
                  df = (f(x + h) - f(x)) / h
                  df_values.append(abs(df))
              except:
                  continue

          if not df_values:
              print("Ошибка: не удалось вычислить производную функции на интервале")
              return None, None, 0

          df_max = max(df_values)

          if df_max < 1e-12:
              print("Ошибка: производная слишком близка к нулю")
              return None, None, 0

          # Выбираем параметр преобразования
          lambda_ = 1 / df_max
          phi = lambda x: x - lambda_ * f(x)

          # Проверяем условие сходимости |phi'(x)| < 1
          dphi_values = []
          for x in x_points:
              try:
                  dphi = (phi(x + h) - phi(x)) / h
                  dphi_values.append(abs(dphi))
              except:
                  continue

          if not dphi_values:
              print("Ошибка: не удалось вычислить производную phi(x)")
              return None, None, 0

          dphi_max = max(dphi_values)

          # Жёсткая проверка условия сходимости
          if dphi_max >= 1:
              print(f"Ошибка: условие сходимости не выполняется (max|phi'|={dphi_max:.3f} ≥ 1)")
              print("Метод простой итерации не может быть применён")
              return None, None, 0

          # Если условие сходимости выполняется, выполняем итерации
          x_prev = (a + b) / 2
          iterations = 0
          max_iter = 1000

          while iterations < max_iter:
              iterations += 1
              try:
                  x_next = phi(x_prev)
              except:
                  print("Ошибка при вычислении phi(x)")
                  return None, None, 0

              if abs(x_next - x_prev) < eps:
                  return x_next, f(x_next), iterations

              x_prev = x_next

          print("Предупреждение: достигнуто максимальное число итераций")
          return x_prev, f(x_prev), iterations

      except Exception as e:
          print(f"Ошибка в методе простой итерации: {str(e)}")
          return None, None, 0

    def plot_function(self, f: Callable[[float], float], a: float, b: float, root: Optional[float] = None):
        """Строит график функции"""
        x = np.linspace(a, b, 400)
        y = np.vectorize(f)(x)

        plt.figure(figsize=(10, 6))
        plt.plot(x, y, label="f(x)")
        plt.axhline(0, color='black', linewidth=0.5)
        plt.axvline(0, color='black', linewidth=0.5)

        if root is not None:
            plt.scatter([root], [f(root)], color='red', label=f"Корень ({root:.5f})")

        plt.title("График функции")
        plt.xlabel("x")
        plt.ylabel("f(x)")
        plt.grid(True)
        plt.legend()
        plt.show()

    def run(self):
      """Основной цикл программы"""
      print("Программа для решения нелинейных уравнений")

      # Выбор уравнения
      eq_choice = self.display_menu(self.equations, "Доступные уравнения")
      eq_name, f = self.equations[eq_choice]
      print(f"\nВыбрано уравнение: {eq_name}")

      # Ввод данных
      a, b, eps = self.get_input_source()
      print(f"\nИсходные данные: a={a}, b={b}, eps={eps}")

      # Проверка интервала
      if not self.verify_interval(f, a, b):
          return

      # Выбор метода
      method_choice = self.display_menu(self.methods, "Доступные методы")
      method_name, method_func = self.methods[method_choice]
      print(f"\nВыбран метод: {method_name}")

      # Вычисление корня
      if method_choice == 3:  # Метод простой итерации
          root, f_root, iterations = method_func(f, a, b, eps)
          # Если метод не выполнился из-за невыполнения условия сходимости
          if root is None:
              print("\nРасчёт не выполнен из-за невыполнения условий сходимости.")
              return
      else:
          x0 = self.find_initial_guess(f, a, b)
          root, f_root, iterations = method_func(f, a, b, eps)

      # Вывод результатов
      output_dest = self.get_output_destination()
      result = (f"\nРезультаты для уравнения {eq_name} на интервале [{a}, {b}]:\n"
              f"Метод: {method_name}\n"
              f"Найденный корень: {root:.8f}\n"
              f"Значение функции в корне: {f_root:.8f}\n"
              f"Количество итераций: {iterations}\n"
              f"Точность: {eps}")

      if output_dest == "screen":
          print(result)
      else:
          with open("result.txt", "w") as f_out:
              f_out.write(result)
          print("Результаты сохранены в файл 'result.txt'")

      # Построение графика
      self.plot_function(f, a, b, root)

if __name__ == "__main__":
    solver = NonlinearEquationSolver()
    solver.run()